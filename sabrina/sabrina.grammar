# JavaExecutor Functions
(def @tempValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.tempValueCast)

(def @paramForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.paramForm)

(def @trigParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.trigParam)
(def @queryParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.queryParam)
(def @actParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.actParam)

(def @cmdForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.cmdForm)

(def @ansForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.ansForm)

(def @jsonOut edu.stanford.nlp.sempre.thingtalk.ThingTalk.jsonOut)

(def @special edu.stanford.nlp.sempre.thingtalk.ThingTalk.special)

# Value Parsing
(rule $NumValue ($PHRASE) (NumberFn) (anchored 1))
(rule $ValueNoString ($PHRASE) (DateFn) (anchored 1))
(rule $ValueNoString ($PHRASE) (TimeFn) (anchored 1))
(rule $ValueNoString ($NumValue) (IdentityFn))
(rule $ValueNoString ($NumValue c) (lambda num (call @tempValueCast (string "C") (var num))))
(rule $ValueNoString ($NumValue f) (lambda num (call @tempValueCast (string "F") (var num))))
(rule $ValueNoString (true) (ConstantFn (boolean true)))
(rule $ValueNoString (false) (ConstantFn (boolean false)))
(rule $Value ($ValueNoString) (IdentityFn))
(rule $Value ($PHRASE) (IdentityFn) (anchored 1))

# FIXME: Integrate this to improve the canonicals
#(rule $PlaceValue ($PHRASE) (FilterNerSpanFn LOCATION) (anchored 1))
#(rule $PersonValue ($PHRASE) (FilterNerSpanFn PERSON) (anchored 1))
#(rule $OrgValue ($PHRASE) (FilterNerSpanFn ORGANIZATION) (anchored 1))

# Argument Names
(rule $ArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param))

# operators
# DO NOT replace this with SimpleLexiconFn or similar: FloatingParser
# must see all the rules to generate all the ops
# also make sure that at most $BeamSize branches belong to this
# category - that way FloatingParser will generate all of them
# and it will be equivalent to writing down all combinations in
# $Arg
(rule $Op (is) (ConstantFn (string is)))
(rule $Op (contains) (ConstantFn (string contains)))
(rule $Op (has) (ConstantFn (string has)))
(rule $Op (is greater than) (ConstantFn (string ">")))
(rule $Op (is less than) (ConstantFn (string "<")))

# Arguments
(rule $Arg ($ArgName $Op $Value) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $ValidArg ($Arg) (thingtalk.FilterInvalidArgFn))

# Action Handling
(rule $ActionName ($PHRASE) (thingtalk.ThingpediaLexiconFn action))
(rule $Action ($ActionName) (lambda act (call @actParam (var act))))
(rule $Action ($Action with $ValidArg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
(rule $ValidAction ($Action) (thingtalk.FilterInvalidInvocationFn))

(rule $TriggerName ($PHRASE) (thingtalk.ThingpediaLexiconFn trigger))
(rule $Trigger ($TriggerName) (lambda trig (call @trigParam (var trig))))
(rule $Trigger ($Trigger and $ValidArg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
(rule $ValidTrigger ($Trigger) (thingtalk.FilterInvalidInvocationFn))

(rule $QueryName ($PHRASE) (thingtalk.ThingpediaLexiconFn query))
(rule $Query ($QueryName) (lambda query (call @queryParam (var query))))
(rule $Query ($Query and $ValidArg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))
(rule $ValidQuery ($Query) (thingtalk.FilterInvalidInvocationFn))

(rule $Notify (monitor if $ValidTrigger) (IdentityFn))

(rule $Device ($TOKEN) (thingtalk.ThingpediaLexiconFn kind))

(rule $Help (help) (ConstantFn (string generic)) (anchored 1))
(rule $Help (help $Device) (IdentityFn))

(rule $Discovery (discover) (ConstantFn (string generic)))
(rule $Discovery (discover $Device) (IdentityFn))

(rule $Configuration (configure) (ConstantFn (string generic)))
(rule $Configuration (configure $Device) (IdentityFn))

(rule $Listing (devices) (ConstantFn (string device)))
(rule $Listing (queries) (ConstantFn (string query)))
(rule $Listing (commands) (ConstantFn (string command)))

(rule $Information (list) (ConstantFn (string generic)))
(rule $Information (list $Listing) (IdentityFn))

# Command handling
(rule $Command ($Help) (lambda value (call @cmdForm (string "help") (var value))))
(rule $Command ($Discovery) (lambda value (call @cmdForm (string "discover") (var value))))
(rule $Command ($Information) (lambda value (call @cmdForm (string "list") (var value))))
(rule $Command ($Configuration) (lambda value (call @cmdForm (string "configure") (var value))))

(rule $Special ($PHRASE) (SimpleLexiconFn (type tt:type.special)))

# Answer handling
# NOTE 1: string answers are handled by putting Sabrina in "raw" mode
# which bypasses sempre
# DO NOT put $Answer -> $StringValue here, it would catch everything and confuse the parser
# NOTE 2: boolean answers are matched to yes/no, which are specials
# but you still need to handle them here to match synonyms of true/false like on/off
# that should not be learned as synonyms of yes/no
(rule $Answer ($ValueNoString) (lambda value (call @ansForm (string "Date") (var value))))

(rule $ROOT ($Command) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($ValidAction) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Notify) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($ValidQuery) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Answer) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Special) (lambda spl (call @special (var spl))))
